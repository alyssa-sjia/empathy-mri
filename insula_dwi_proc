%% init
% NOTE : dependencies
% micaopen: SurfStat - see also BrainStat for similar functions
% micasoft: mica_parcelData2surfData
% gifti: in micasoft but can also be downloaded directly
% micapipe: surface files

for set_directories = 1
    
    % directories
    GH = '/data/u_nunnink_software';
    micaopen = [GH, '/micaopen'];
    micapipe = [GH, '/micapipe'];
    micasoft = [GH, '/micasoft-master'];
    dataset = '/data/p_03140/BIDS_spacetop';
    deriv_dir = [dataset, '/derivatives'];
    micapipe_deriv = [deriv_dir, '/micapipe_v0.2.0'];
    
    % set path
    addpath(genpath([micaopen,'/surfstat']));
    addpath(genpath([micaopen,'/mica_powertools']));
    addpath(genpath([micasoft,'/matlab/gifti-1.6']));

    % surface
    tmp = gifti([micapipe,'/surfaces/fsLR-32k.L.surf.gii']);
    lh = struct(); lh.coord = tmp.vertices'; lh.tri = tmp.faces;
    tmp = gifti([micapipe,'/surfaces/fsLR-32k.R.surf.gii']);
    rh = struct(); rh.coord = tmp.vertices'; rh.tri = tmp.faces;
    clear tmp
    surf = struct(); surf.coord = [lh.coord, rh.coord]; surf.tri = [lh.tri; rh.tri+max(max(lh.tri))]; 
    nFS = length(surf.coord);
end

%% subject info

id = 'sub-0017';
ses = 'ses-01';
dwi_maps_dir = [micapipe_deriv, '/', id, '/', ses, '/maps/'];

%% structural info

metric = 'FA';
surfname = 'fsLR-32k';
label = 'midthickness';

% load diffusion file
hemi = 'L';
fname = [dwi_maps_dir, '/', id, '_', ses, '_hemi-', hemi, '_surf-', surfname, '_label-', label, '_', metric,'.func.gii'];
g = gifti(fname);
dataL = g.cdata;
nVertL = length(dataL);

hemi = 'R';
fname = [dwi_maps_dir, '/', id, '_', ses, '_hemi-', hemi, '_surf-', surfname, '_label-', label, '_', metric,'.func.gii'];
g = gifti(fname);
dataR = g.cdata;
nVertR = length(dataR);

fa = [dataL; dataR];
figure, SurfStatViewData(fa,surf); colormap(parula); SurfStatColLim([0, 1])

faSm = SurfStatSmooth(fa',surf,5);
figure, SurfStatViewData(faSm,surf); colormap(parula); SurfStatColLim([0.2 0.8])


%% Load parcellation

parcName = 'economo';
parcIDsL = [20 19 14];
parcIDsR = [64 63 58];
nInsulaRoi = length(parcIDsL);

for load_parc = 1
    
    % Read parccellation for C69
    parcFS = csvread([micapipe, '/parcellations/', parcName, '_conte69.csv']);
    parcFS = parcFS + 1;

    uparc = unique(parcFS);
    parcFSR = parcFS(nFS/2+1:end);
    uparcR = unique(parcFSR);
    
    maskCol = 1; % value of mask in parcellation
    maskIdxFS = find(parcFS == maskCol(1));
    maskParc = zeros(1,nFS); maskParc(1,maskIdxFS) = 1;
    
end
figure, SurfStatViewData(parcFS,surf); colormap(parula); 

% isolate insula parcels 
insulaRoiL = zeros(size(parcFS));
insulaRoiR = zeros(size(parcFS));
for ii = 1:nInsulaRoi
    insulaRoiL(parcFS == parcIDsL(ii)) = ii;
    insulaRoiR(parcFS == parcIDsR(ii)) = ii;
end

figure, SurfStatViewData(insulaRoiL,surf); colormap(parula); 
figure, SurfStatViewData(insulaRoiR,surf); colormap(parula); 


%% Check for differences in FA across insula parcels

% Left
faVal = {};
roiID = {};
for roi = 1:nInsulaRoi
    roiIdx = find(insulaRoiL == roi);
    faVal{roi} = fa(roiIdx);
    roiID{roi} = zeros(length(roiIdx),1)+roi;
end

tmpData = [vertcat(faVal{:}), vertcat(roiID{:})];
figure, boxplot(tmpData(:,1), tmpData(:,2))















%%%%%

for load_parc = 1
    
    % Read parcellation for C69
    parcFS = csvread([micapipe, '/parcellations/', parcName, '_conte69.csv']);
    parcFS = parcFS + 1;
    uparc = unique(parcFS);

    nTotal = length(parcFS);
    nHemi  = nTotal / 2;

    if hemi == 'L'
        parcHemi = parcFS(1:nHemi);
    elseif hemi == 'R'
        parcHemi = parcFS(nHemi+1:end);
    end

    % Sanity check
    if nHemi ~= nVert
        error('Parcellation and diffusion vertices unequal')
    end
  
    maskCol = 1; % value of mask in parcellation
    maskIdxFS = find(parcFS == maskCol(1));
    maskParc = zeros(1,nFS); maskParc(1,maskIdxFS) = 1;
    
end


% viz
tp = 10;
figure, SurfStatViewData(fslr32k(tp,:),surf); colormap(parula); SurfStatColLim([-20000, 20000])

% deleted smooth and corr

%% load FC: parcellation

fc = gifti([func_task_surf_dir, '/', id, '_', ses, '_atlas-', parcName,'_desc-FC.shape.gii']);
fc = fc.cdata;
fc = fc + fc';
diagonalMask = logical(eye(size(fc)));
fc(diagonalMask) = 0;
z = .5 * log( (1+fc) ./ (1-fc) );

% define indices for subcortex, cerebellum, and cortex
sctx = 1:14;
cerebel = 15:48;
ctx = 49:size(z,1);

% remake FC to keep what we want
fcSctx = z(sctx, :);
fcCerebel = z(cerebel, :); 
fcCtx = z(ctx,:); 

fcStxCtx = [fcSctx;fcCtx];
fcStxCtx(:,cerebel) = []; % remove cerebellum
ctxStart = length(sctx)+1;

%% Visualization

% left and right thalamus: cortical connectivity
seed = 1; 
seedFC = fcStxCtx(seed,:);
data = mica_parcelData2surfData(seedFC(ctxStart:end), surf, parcFS);
data(maskParc == 1) = 0;
figure, SurfStatViewData(data, surf), colormap("parula"); SurfStatColLim([0 1])

seed = 8;
seedFC = fcStxCtx(seed,:);
data = mica_parcelData2surfData(seedFC(ctxStart:end), surf, parcFS);
data(maskParc == 1) = 0;
figure, SurfStatViewData(data, surf), colormap("parula"); SurfStatColLim([0 1])

% Left and right dlpfc: cortical connectivity
seed = 195; 
seedFC = fcStxCtx(seed,:);
data = mica_parcelData2surfData(seedFC(ctxStart:end), surf, parcFS);
data(maskParc == 1) = 0;
figure, SurfStatViewData(data, surf), colormap("parula"); SurfStatColLim([0 1])

seed = 401;
seedFC = fcStxCtx(seed,:);
data = mica_parcelData2surfData(seedFC(ctxStart:end), surf, parcFS);
data(maskParc == 1) = 0;
figure, SurfStatViewData(data, surf), colormap("parula"); SurfStatColLim([0 1])

